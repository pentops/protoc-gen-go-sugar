package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "1.0"

var includeDriverValue *bool

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-sugar %v\n", version)
		return
	}

	var flags flag.FlagSet
	includeDriverValue = flags.Bool("sql_driver", true, "enum types will implement sql.Valuer for the short string")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a _sugar.pb.go
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_sugar.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-sugar. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, message := range file.Messages {
		genMessage(g, message)
	}

	for _, enum := range file.Enums {
		genEnum(g, enum)
	}

	return g
}

func isOneofWrapper(message *protogen.Message) bool {
	// special case
	if len(message.Oneofs) != 1 {
		return false
	}

	if !strings.HasSuffix(message.GoIdent.GoName, "Type") {
		return false
	}

	messageFullName := message.Desc.FullName()
	unique := make(map[string]struct{})

	oneofName := message.Oneofs[0].GoName
	if oneofName != "Type" {
		return false
	}
	for _, field := range message.Fields {
		if field.Message == nil {
			// All oneof fields must be a message
			return false
		}
		if field.Message.Desc.Parent().FullName() != messageFullName {
			// All oneof fields must be a message within the oneof wrapper
			return false
		}
		if _, ok := unique[field.Message.GoIdent.GoName]; ok {
			// All oneof fields must be unique
			return false
		}
		unique[field.Message.GoIdent.GoName] = struct{}{}

		if field.Oneof == nil || field.Oneof.GoName != oneofName {
			return false
		}
	}

	return true
}

func genMessage(g *protogen.GeneratedFile, message *protogen.Message) {

	if isOneofWrapper(message) {
		g.P("//"+message.GoIdent.GoName, " is a oneof wrapper")
		prefix := strings.TrimSuffix(message.GoIdent.GoName, "Type")

		typeKeyName := prefix + "TypeKey"
		isATypeName := "Is" + message.GoIdent.GoName + "WrappedType"
		g.P("type ", typeKeyName, " string")
		g.P("const (")
		for _, field := range message.Fields {
			g.P(prefix, "_", field.GoName, " ", typeKeyName, ` = "`, field.Desc.JSONName(), `"`)
		}
		g.P(")") // end const

		g.P("func (x *", message.GoIdent, ") TypeKey() (", typeKeyName, ", bool) {")
		g.P("	switch x.Type.(type) {")
		for _, field := range message.Fields {
			g.P("	case *", field.GoIdent, ":")
			g.P("		return ", prefix, "_", field.GoName, ", true")
		}
		g.P("	default:")
		g.P("		return \"\", false")
		g.P("	}")
		g.P("}")

		g.P("type ", isATypeName, " interface {")
		g.P("	TypeKey() ", typeKeyName)
		g.P("}")

		g.P("func (x *", message.GoIdent, ") Set(val ", isATypeName, ") {")
		g.P("	switch v := val.(type) {")
		for _, field := range message.Fields {
			g.P("	case *", field.Message.GoIdent, ":")
			g.P("		x.Type = &", field.GoIdent, "{", field.GoName, ": v}")
		}
		g.P("	}")
		g.P("}")

		g.P("func (x *", message.GoIdent, ") Get() ", isATypeName, " {")
		g.P("	switch v := x.Type.(type) {")
		for _, field := range message.Fields {
			g.P("	case *", field.GoIdent, ":")
			g.P("		return v.", field.GoName)
		}
		g.P("	default:")
		g.P("		return nil")
		g.P("	}")
		g.P("}")

		for _, field := range message.Fields {
			g.P("func (x *", field.Message.GoIdent, ") TypeKey() ", typeKeyName, "  {")
			g.P("		return ", prefix, "_", field.GoName)
			g.P("}")
		}

	}

	for _, oneof := range message.Oneofs {
		// proto3 optional fields create synthetic oneofs, which should be skipped here
		// https://github.com/protocolbuffers/protobuf/blob/v22.0/src/google/protobuf/descriptor.proto#L219

		if !oneof.Desc.IsSynthetic() {
			g.P("type Is", message.GoIdent.GoName, "_", oneof.GoName, " = is", message.GoIdent.GoName, "_", oneof.GoName)
		}
	}

	for _, subMessage := range message.Messages {
		genMessage(g, subMessage)
	}
}

func genEnum(g *protogen.GeneratedFile, enum *protogen.Enum) {
	g.P("//" + enum.GoIdent.GoName)

	if len(enum.Values) == 0 {
		return
	}

	firstEntryName := string(enum.Values[0].Desc.Name())
	if !strings.HasSuffix(firstEntryName, "_UNSPECIFIED") {
		return
	}

	prefix := strings.TrimSuffix(firstEntryName, "UNSPECIFIED")

	g.P("const (")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P(enum.GoIdent.GoName, "_", shortName, " ", enum.GoIdent, " = ", val.Desc.Number())
	}
	g.P(")") // end const

	g.P("var (")

	g.P(enum.GoIdent.GoName, "_name_short = map[int32]string{")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P(val.Desc.Number(), ": \"", shortName, "\",")
	}
	g.P("}") // end map

	g.P(enum.GoIdent.GoName, "_value_short = map[string]int32{")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P("\"", shortName, "\":", val.Desc.Number(), ",")
	}
	g.P("}") // end map

	g.P(enum.GoIdent.GoName, "_value_either = map[string]int32{")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P("\"", shortName, "\":", val.Desc.Number(), ",")
		g.P("\"", val.Desc.Name(), "\":", val.Desc.Number(), ",")
	}
	g.P("}") // end map

	g.P(")") // end var

	g.P("// ShortString returns the un-prefixed string representation of the enum value")
	g.P("func (x ", enum.GoIdent, ") ShortString() string {")
	g.P("	return ", enum.GoIdent.GoName, "_name_short[int32(x)]")
	g.P("}")

	if *includeDriverValue {
		g.P("func (x ", enum.GoIdent, ") Value() (", driverPackage.Ident("Value"), ", error) {")
		g.P("	return []uint8(x.ShortString()), nil")
		g.P("}")

		g.P("func (x *", enum.GoIdent, ") Scan(value interface{}) error {")
		g.P("	var strVal string")
		g.P("	switch vt := value.(type) {")
		g.P("	case []uint8:")
		g.P("		strVal = string(vt)")
		g.P("	case string:")
		g.P("		strVal = vt")
		g.P("	default:")
		g.P("		return ", protogen.GoImportPath("fmt").Ident("Errorf"), "(\"invalid type %T\", value)")
		g.P("	}")
		g.P("	val := ", enum.GoIdent.GoName, "_value_either[strVal]")
		g.P("	*x = ", enum.GoIdent, "(val)")
		g.P("	return nil")
		g.P("}")
	}
}

var driverPackage = protogen.GoImportPath("database/sql/driver")
