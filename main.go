package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "1.0"

var includeDriverValue *bool

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-sugar %v\n", version)
		return
	}

	var flags flag.FlagSet
	includeDriverValue = flags.Bool("sql_driver", true, "enum types will implement sql.Valuer for the short string")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a _sugar.pb.go
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_sugar.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-sugar. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, message := range file.Messages {
		genMessage(g, message)
	}

	for _, enum := range file.Enums {
		genEnum(gen, file, g, enum)
	}

	return g
}

func genMessage(g *protogen.GeneratedFile, message *protogen.Message) {
	for _, oneof := range message.Oneofs {
		g.P("type Is", message.GoIdent.GoName, "_", oneof.GoName, " = is", message.GoIdent.GoName, "_", oneof.GoName)
	}

	for _, subMessage := range message.Messages {
		genMessage(g, subMessage)
	}
}

func genEnum(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, enum *protogen.Enum) {
	g.P("//" + enum.GoIdent.GoName)

	if len(enum.Values) == 0 {
		return
	}

	firstEntryName := string(enum.Values[0].Desc.Name())
	if !strings.HasSuffix(firstEntryName, "_UNSPECIFIED") {
		return
	}

	prefix := strings.TrimSuffix(firstEntryName, "UNSPECIFIED")

	g.P("const (")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P(enum.GoIdent.GoName, "_", shortName, " ", enum.GoIdent, " = ", val.Desc.Number())
	}
	g.P(")") // end const

	g.P("var (")

	g.P(enum.GoIdent.GoName, "_name_short = map[int32]string{")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P(val.Desc.Number(), ": \"", shortName, "\",")
	}
	g.P("}") // end map

	g.P(enum.GoIdent.GoName, "_value_short = map[string]int32{")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P("\"", shortName, "\":", val.Desc.Number(), ",")
	}
	g.P("}") // end map

	g.P(enum.GoIdent.GoName, "_value_either = map[string]int32{")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P("\"", shortName, "\":", val.Desc.Number(), ",")
		g.P("\"", val.Desc.Name(), "\":", val.Desc.Number(), ",")
	}
	g.P("}") // end map

	g.P(")") // end var

	g.P("// ShortString returns the un-prefixed string representation of the enum value")
	g.P("func (x ", enum.GoIdent, ") ShortString() string {")
	g.P("	return ", enum.GoIdent.GoName, "_name_short[int32(x)]")
	g.P("}")

	if *includeDriverValue {
		g.P("func (x ", enum.GoIdent, ") Value() (", driverPackage.Ident("Value"), ", error) {")
		g.P("	return []uint8(x.ShortString()), nil")
		g.P("}")

		g.P("func (x *", enum.GoIdent, ") Scan(value interface{}) error {")
		g.P("	var strVal string")
		g.P("	switch vt := value.(type) {")
		g.P("	case []uint8:")
		g.P("		strVal = string(vt)")
		g.P("	case string:")
		g.P("		strVal = vt")
		g.P("	default:")
		g.P("		return ", protogen.GoImportPath("fmt").Ident("Errorf"), "(\"invalid type %T\", value)")
		g.P("	}")
		g.P("	val := ", enum.GoIdent.GoName, "_value_either[strVal]")
		g.P("	*x = ", enum.GoIdent, "(val)")
		g.P("	return nil")
		g.P("}")
	}
}

var driverPackage = protogen.GoImportPath("database/sql/driver")
